Cintcode Mnemonic,Operands,Cintcode Meaning,ARM64 Specific Notes
Loading Values,,,
Ln,0 <= n <= 10,B := A; A := n,"MOV x1, x0; MOV x0, #n. Simple immediate load."
LM1,,B := A; A := -1,"MOV x1, x0; MOV x0, #-1. Immediate load."
L b,0 <= b <= 255,B := A; A := b,"MOV x1, x0; MOV x0, #b. Immediate load."
LM b,0 <= b <= 255,B := A; A := -b,"MOV x1, x0; MOVN x0, #b (if b is suitable for MOVN), or SUB x0, xzr, #b."
LH h,0 <= h <= 65535,B := A; A := h,"MOV x1, x0; MOV x0, #h. May require MOVZ/MOVK pair for 16-bit immediate if h > 255."
LMH h,0 <= h <= 65535,B := A; A := -h,"MOV x1, x0; SUB x0, xzr, #h. May require MOVZ/MOVK pair for 16-bit immediate if h > 255."
LW w,w,B := A; A := w,"MOV x1, x0; MOV x0, #w. w is a 32-bit signed value. Sign-extended to 64-bit. For true 64-bit w, uses MOVZ/MOVK or literal pool."
MW w,w,MW := w,"MOV x25, #w. w is a 32-bit value (sign-extended to 64-bit for x25)."
LPn,3 <= n <= 16,B := A; A := P!n,"MOV x1, x0; LDR x0, [x29, #(n*8)]. Direct load from FP-relative stack."
LP b,b,B := A; A := P!b,"MOV x1, x0; LDR x0, [x29, #(b*8)]."
LPH h,h,B := A; A := P!h,"MOV x1, x0; LDR x0, [x29, #(h*8)]. h is 16-bit unsigned offset, effectively h*8 as byte offset."
LPW w,w,B := A; A := P!w,"MOV x1, x0; LDR x0, [x29, #(w*8)]. w is 32-bit signed offset."
LG b,b,B := A; A := G!b,"MOV x1, x0; LDR x0, [x28, #(b*8)]. Direct load from Global Pointer."
LG1 b,b,B := A; A := G!(b + 256),"MOV x1, x0; LDR x0, [x28, #((b+256)*8)]."
LGH h,h,B := A; A := G!h,"MOV x1, x0; LDR x0, [x28, #(h*8)]."
LL Ln,Ln,B := A; A := variable Ln,"MOV x1, x0; ADRP x0, Ln@PAGE; ADD x0, x0, Ln@PAGEOFF; LDR x0, [x0]. Loads content of static variable."
LL$ Ln,Ln,B := A; A := variable Ln,"MOV x1, x0; ADRP x0, Ln@PAGE; ADD x0, x0, Ln@PAGEOFF; LDR x0, [x0]. Indirect variant, same effect if Ln is direct address."
LF Ln,Ln,B := A; A := entry point Ln,"MOV x1, x0; ADRP x0, Ln@PAGE; ADD x0, x0, Ln@PAGEOFF. Loads the absolute address of code label Ln."
LF$ Ln,Ln,B := A; A := entry point Ln,"MOV x1, x0; ADRP x0, Ln@PAGE; ADD x0, x0, Ln@PAGEOFF. Indirect variant."
LLP b,b,B := A; A := @P!b,"MOV x1, x0; ADD x0, x29, #(b*8). Calculates address of local variable."
LLPH h,h,B := A; A := @P!h,"MOV x1, x0; ADD x0, x29, #(h*8)."
LLPW w,w,B := A; A := @P!w,"MOV x1, x0; ADD x0, x29, #(w*8). Uses the sign-extended w to calculate offset."
LLG b,b,B := A; A := @G!b,"MOV x1, x0; ADD x0, x28, #(b*8). Calculates address of global variable."
LLG1 b,b,B := A; A := @G!(b+256),"MOV x1, x0; ADD x0, x28, #((b+256)*8)."
LLGH h,h,B := A; A := @G!h,"MOV x1, x0; ADD x0, x28, #(h*8)."
LLL Ln,Ln,B := A; A := @(variable Ln),"MOV x1, x0; ADRP x0, Ln@PAGE; ADD x0, x0, Ln@PAGEOFF. Loads the absolute address of static variable Ln."
LLL$ Ln,Ln,B := A; A := @(variable Ln),"MOV x1, x0; ADRP x0, Ln@PAGE; ADD x0, x0, Ln@PAGEOFF. Indirect variant."
Indirect Load,,,
GBYT,,A := B%A,"LDRB x0, [x1, x0]. Loads byte at x1 + x0 (byte offset)."
RV,,A := A!0,"LDR x0, [x0]. Loads the 64-bit word at the address in x0."
RVn,1 <= n <= 6,A := A!n,"LDR x0, [x0, #(n*8)]. Loads the n-th word (64-bit) from the base address in x0."
RVPn,3 <= n <= 7,A := P!n!A,"LDR x_temp, [x29, #(n*8)]; LDR x0, [x_temp, x0, LSL #3]. Loads A from P!n offset by A (word index)."
L0Pn,3 <= n <= 12,B := A; A := P!n!0,"MOV x1, x0; LDR x_temp, [x29, #(n*8)]; LDR x0, [x_temp]."
L1Pn,3 <= n <= 6,B := A; A := P!n!1,"MOV x1, x0; LDR x_temp, [x29, #(n*8)]; LDR x0, [x_temp, #8]."
L2Pn,3 <= n <= 5,B := A; A := P!n!2,"MOV x1, x0; LDR x_temp, [x29, #(n*8)]; LDR x0, [x_temp, #16]."
L3Pn,3 <= n <= 4,B := A; A := P!n!3,"MOV x1, x0; LDR x_temp, [x29, #(n*8)]; LDR x0, [x_temp, #24]."
L4Pn,3 <= n <= 4,B := A; A := P!n!4,"MOV x1, x0; LDR x_temp, [x29, #(n*8)]; LDR x0, [x_temp, #32]."
LnG b,0 <= n <= 2,B := A; A := G!b!n,"MOV x1, x0; LDR x_temp, [x28, #(b*8)]; LDR x0, [x_temp, #(n*8)]."
LnG1 b,0 <= n <= 2,B := A; A := G!(b+256)!n,"MOV x1, x0; LDR x_temp, [x28, #((b+256)*8)]; LDR x0, [x_temp, #(n*8)]."
LnGH h,0 <= n <= 2,B := A; A := G!h!n,"MOV x1, x0; LDR x_temp, [x28, #(h*8)]; LDR x0, [x_temp, #(n*8)]."
Expression Operators,,,
NEG,,A := -A,"NEG x0, x0."
NOT,,A := ~A,"MVN x0, x0."
MUL,,A := B * A,"MUL x0, x1, x0. Uses SMULH/UMULH for 128-bit results if needed (implied by MDIV context), but for A := B * A, MUL (64-bit) is sufficient."
DIV,,A := B / A,"SDIV x0, x1, x0 (signed division). Requires explicit check for A=0 to raise exception 5."
MOD,,A := B MOD A,"SDIV x_temp, x1, x0; MLS x0, x_temp, x0, x1 (remainder calculation for signed div). Requires explicit check for A=0."
ADD,,A := B + A,"ADD x0, x1, x0."
SUB,,A := B - A,"SUB x0, x1, x0."
LSH,,A := B << A,"LSL x0, x1, x0. Shift amount (A) is masked by 63."
RSH,,A := B >> A,"LSR x0, x1, x0 (logical right shift). ASR for arithmetic right shift if context requires signed shift. Shift amount (A) is masked by 63."
AND,,A := B & A,"AND x0, x1, x0."
OR,,`A := B \,A`
XOR,,A := B XOR A,"EOR x0, x1, x0."
An,1 <= n <= 5,A := A + n,"ADD x0, x0, #n."
Sn,1 <= n <= 4,A := A - n,"SUB x0, x0, #n."
A b,b,A := A + b,"ADD x0, x0, #b."
AH h,h,A := A + h,"ADD x0, x0, #h."
AW w,w,A := A + w,"ADD x0, x0, #w. w is 32-bit value, sign-extended. If w is large, may require multiple MOV or literal pool."
S b,b,A := A - b,"SUB x0, x0, #b."
SH h,h,A := A - h,"SUB x0, x0, #h."
APn,3 <= n <= 12,A := A + P!n,"LDR x_temp, [x29, #(n*8)]; ADD x0, x0, x_temp."
AP b,b,A := A + P!b,"LDR x_temp, [x29, #(b*8)]; ADD x0, x0, x_temp."
APH h,h,A := A + P!h,"LDR x_temp, [x29, #(h*8)]; ADD x0, x0, x_temp."
APW w,w,A := A + P!w,"LDR x_temp, [x29, #(w*8)]; ADD x0, x0, x_temp."
AG b,b,A := A + G!b,"LDR x_temp, [x28, #(b*8)]; ADD x0, x0, x_temp."
AG1 b,b,A := A + G!(b+256),"LDR x_temp, [x28, #((b+256)*8)]; ADD x0, x0, x_temp."
AGH h,h,A := A + G!h,"LDR x_temp, [x28, #(h*8)]; ADD x0, x0, x_temp."
Simple Assignment,,,
SPn,3 <= n <= 16,P!n := A,"STR x0, [x29, #(n*8)]. Stores x0 to FP-relative stack."
SP b,b,P!b := A,"STR x0, [x29, #(b*8)]."
SPH h,h,P!h := A,"STR x0, [x29, #(h*8)]."
SPW w,w,P!w := A,"STR x0, [x29, #(w*8)]."
SG b,b,G!b := A,"STR x0, [x28, #(b*8)]. Stores x0 to Global Pointer relative."
SG1 b,b,G!(b+256) := A,"STR x0, [x28, #((b+256)*8)]."
SGH h,h,G!h := A,"STR x0, [x28, #(h*8)]."
SL Ln,Ln,variable Ln := A,"ADRP x_temp, Ln@PAGE; ADD x_temp, x_temp, Ln@PAGEOFF; STR x0, [x_temp]. Stores x0 to static variable Ln."
SL$ Ln,Ln,variable Ln := A,"ADRP x_temp, Ln@PAGE; ADD x_temp, x_temp, Ln@PAGEOFF; STR x0, [x_temp]. Indirect variant, same effect."
Indirect Assignment,,,
PBYT,,B%A := C,"STRB x2, [x1, x0]. Stores byte x2 to x1 + x0."
XPBYT,,A%B := C,"STRB x2, [x0, x1]. Stores byte x2 to x0 + x1."
ST,,A!0 := B,"STR x1, [x0]. Stores word x1 to address x0."
STn,1 <= n <= 3,A!n := B,"STR x1, [x0, #(n*8)]."
ST0Pn,3 <= n <= 4,P!n!0 := A,"LDR x_temp, [x29, #(n*8)]; STR x0, [x_temp]."
ST1Pn,3 <= n <= 4,P!n!1 := A,"LDR x_temp, [x29, #(n*8)]; STR x0, [x_temp, #8]."
STPn,3 <= n <= 5,P!n!A := B,"LDR x_temp, [x29, #(n*8)]; STR x1, [x_temp, x0, LSL #3]. Stores B to P!n offset by A (word index)."
S0G b,b,G!b!0 := A,"LDR x_temp, [x28, #(b*8)]; STR x0, [x_temp]."
S0G1 b,b,G!(b+256)!0 := A,"LDR x_temp, [x28, #((b+256)*8)]; STR x0, [x_temp]."
S0GH h,h,G!h!0 := A,"LDR x_temp, [x28, #(h*8)]; STR x0, [x_temp]."
Function and Routine Calls,,,
Kn,3 <= n <= 11,"Call A, stack increment n. Args in x0, x1 etc.","Prologue: Save FP, LR. Allocate stack frame n*8 bytes. Update FP. Store previous FP, LR. &lt;br> Call: BLR x_target_address. Args x0, x1 etc. are loaded before the call. x0 holds A, x1 holds B for first two args. Remaining args (if any) are on stack."
"K b, KH h, KW w","b, h, w","Call A, stack increment b/h/w.","Similar to Kn, but with larger stack increments. w is 32-bit signed and extended to 64-bit."
KnG b,3 <= n <= 11,"Call G!b, stack increment n. Args in x0, x1 etc.","Similar to Kn, but target address loaded from G!b into a temporary register first."
"KnG1 b, KnGH h","b, h","Call G!(b+256)/G!h, stack increment n.","Similar to KnG b, with adjusted global offsets."
RTN,,Return from current function.,"Epilogue: Restore FP (MOV x29, x_old_fp), LR (LDR x30, [x29, #offset]), deallocate stack. RET instruction to return. x0 retains function result."
Flow of Control and Relations,,,
J Ln,Ln,PC := Ln,B <label_Ln>. Unconditional branch. Relative addressing is handled by assembler.
J$ Ln,Ln,PC := Ln,"B <label_Ln>. Indirect variant, same effect."
Jrel Ln,Ln,IF B rel A DO PC := Ln,"CMP x1, x0. Then B.<cond> <label_Ln> (e.g., B.EQ, B.NE, B.LT, etc.)."
Jrel$ Ln,Ln,IF B rel A DO PC := Ln,"CMP x1, x0. Then B.<cond> <label_Ln>. Indirect variant."
Jrel0 Ln,Ln,IF A rel 0 DO PC := Ln,"CMP x0, #0. Then B.<cond> <label_Ln>."
Jrel0$ Ln,Ln,IF A rel 0 DO PC := Ln,"CMP x0, #0. Then B.<cond> <label_Ln>. Indirect variant."
GOTO,,PC := A,BR x0. Branches to address held in x0.
FHOP,,A := 0; PC := PC+1,"This is a specific instruction for relational expressions. If the condition is false, x0 is set to 0. If true, x0 is set to -1. Often followed by an instruction that modifies x0 based on the condition code flags. E.g., CSET x0, EQ (if equality check)."
Switch Instructions,,,
SWL,filler n dlab L0...Ln-1,Label vector switch on A.,"For dense, small ranges, can be implemented with a jump table: ADRP x_table, table@PAGE; ADD x_table, x_table, table@PAGEOFF; LDR x_target, [x_table, x0, LSL #3]; BR x_target. For sparse ranges, a series of CMP/B.EQ or TBZ/TBNZ."
SWB,filler n dlab K1 L1...Kn Ln,Binary chop switch on A.,"Implemented as a series of CMP and conditional branches (B.LT, B.GT, B.EQ) to traverse a binary search tree (or similar logic) on the constants Ki to find the target label Li."
Miscellaneous,,,
XCH,,Exchange A and B,"EOR x0, x0, x1; EOR x1, x0, x1; EOR x0, x0, x1. Or MOV x_temp, x0; MOV x0, x1; MOV x1, x_temp (if x_temp is available)."
ATB,,B := A,"MOV x1, x0."
ATC,,C := A,"MOV x2, x0."
BTC,,C := B,"MOV x2, x1."
NOP,,No operation,NOP.
SYS,,System call,"BL <dosys_c_function>. Calls a C function that handles system primitives (dosys). Parameters passed via x0, x1 etc."
MDIV,,Divides P!5 into P!3 * P!4 (double length product).,"Calls a specific helper function (BL <muldiv_c_function>) or uses ARM64's 128-bit multiplication/division instructions (UMULH, SMULH, SDIV, UDIV) to compute 128-bit product and division/remainder. Result in x0, remainder in a global variable (e.g., result2)."
CHGCO,,Coroutine context switch,"Calls a specialized C function (BL <changeco_c_function>) that saves/restores FP, LR, and other callee-saved registers of the involved coroutines. This is a complex operation requiring careful state management."
BRK,,Debugger breakpoint,"BRK #0x1. Triggers a software breakpoint exception, typically handled by a debugger."
Floating-Point Instructions,,,
FLTOP 1 b,b,A := floating_point(A * 10^b),"FMOV d_temp, x0 (move int to float reg); FCVT if needed; then FMUL d_temp, d_temp, #10.0; FMOV x0, d_temp. Or call sys(Sys_flt, fl_mk, A, b)."
FLTOP 3,,A := FLOAT A,"SCVTF d0, x0 (signed integer to floating-point)."
FLTOP 4,,A := FIX A,"FCVTZS x0, d0 (floating-point to signed integer, rounding toward zero)."
FLTOP 5,,A := #ABS A,"FABS d0, d0. (assuming A is in d0)."
FLTOP 6-9,,"#*, #/, #+, #- operations (A := B op A)","FMUL d0, d1, d0; FDIV d0, d1, d0; FADD d0, d1, d0; FSUB d0, d1, d0. (assuming A is in d0, B in d1)."
FLTOP 10,,A := #+A,"FMOV d0, d0. (no-op)."
FLTOP 11,,A := #-A,"FNEG d0, d0."
FLTOP 12-17,,"#=, #~=, #<, #>, #<=, #>= (A := B rel A)","FCMPE d1, d0. Then CSET x0, <cond> (sets x0 to 1 if true, 0 if false, based on floating-point condition flags). x0 is then negated if Cintcode expects -1 for true."
Select Instructions,,,
SELLD len sh,"len, sh",A := SLCT len:sh:0 OF A,"UBFX x0, x0, #sh, #len (unsigned bitfield extract) or SBFX x0, x0, #sh, #len (signed bitfield extract), based on context."
SELST 0 len sh,"len, sh",SLCT len:sh:0 OF A := B,"BFI x0, x1, #sh, #len (bitfield insert). x0 (target value) is updated with x1 (source value) in the specified bitfield."
SELST op len sh,"op, len, sh",SLCT len:sh:0 OF A op:= B,"Complex. Involves LDR to get A's value, SBFX/UBFX to extract field, perform op with B, then BFI/BFIL to insert modified value back into A's location. This often translates to a sequence of LDR, AND/ORR/ADD/SUB, BFI/BFIL, STR."